<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TPY Staking DApp</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    input, button, textarea { padding: 0.5rem; margin: 0.5rem 0; }
    .section { border: 1px solid #ddd; padding: 1rem; margin-bottom: 2rem; }
    .result { margin-top: 1rem; }
    label { display: block; margin-top: 1rem; }
    pre { background: #f8f8f8; padding: 0.5rem; }
    /* Pool list styling */
    .pool-grid { display: block; margin: 1rem 0; }
    .pool-card {
      border: 1px solid #ddd;
      padding: 1rem;
      border-radius: 4px;
      background: #f8f8f8;
      margin-bottom: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pool-card.paused { background: #fff0f0; }
    .pool-info { flex: 1; }
    .pool-actions { flex: 0 0 auto; margin-left: 1rem; }
    .pool-actions input { width: 120px; margin-right: 0.5rem; }
    .pool-actions button { margin-right: 0.5rem; }
    .refresh-button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: 4px;
    }
    .refresh-button:hover { background: #45a049; }
  </style>
</head>
<body>
  <!-- Network Selection -->
  <div class="section">
    <h2>Network Configuration</h2>
    <label for="networkSelect">Select Network:</label>
    <select id="networkSelect">
      <option value="sepolia">Sepolia</option>
      <option value="mainnet">Mainnet</option>
      <option value="goerli">Goerli</option>
      <option value="rinkeby">Rinkeby</option>
    </select>
  </div>
  
  <!-- Available Pools Section (read-only) -->
  <h1>TPY Staking DApp</h1>
  <div class="section">
    <h2>Available Pools</h2>
    <button id="refreshPoolsButton" class="refresh-button">Refresh Pools</button>
    <div id="poolList" class="pool-grid">
      <!-- Pool cards will be dynamically inserted here -->
    </div>
  </div>
  
  <!-- Wallet Connection -->
  <div class="section">
    <h2>Wallet Connection</h2>
    <button id="connectWalletButton">Connect Wallet</button>
    <p><strong>Connected Address:</strong> <span id="walletAddress">Not connected</span></p>
  </div>
  
  <!-- (Optional) Additional Global Write and Read Sections can go here -->
  
  <script>
    // Fixed contract address (update if needed)
    const CONTRACT_ADDRESS = "0xBbB449a875bAD0bc422758F0E08e86202E500eD3";
    
    // Network parameters (update RPC endpoints as needed)
    const NETWORKS = {
      sepolia: { chainId: 11155111, rpc: "https://rpc.sepolia.org" },
      mainnet: { chainId: 1, rpc: "https://mainnet.infura.io/v3/YOUR_INFURA_KEY" },
      goerli: { chainId: 5, rpc: "https://goerli.infura.io/v3/YOUR_INFURA_KEY" },
      rinkeby: { chainId: 4, rpc: "https://rinkeby.infura.io/v3/YOUR_INFURA_KEY" }
    };
    
    // Global wallet variables for write functions
    let signer;
    let contract;
    
    // Helper functions for formatting
    function formatDuration(seconds) {
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      let result = [];
      if (days > 0) result.push(`${days} days`);
      if (hours > 0) result.push(`${hours} hours`);
      if (minutes > 0) result.push(`${minutes} minutes`);
      return result.join(', ') || 'less than a minute';
    }
    
    function formatAPY(apy) {
      return (apy / 100).toFixed(2) + '%';
    }
    
    function formatTokens(amount) {
      return ethers.utils.formatEther(amount);
    }
    
    // Create a read-only provider and contract instance based on selected network
    function getPublicContract() {
      const networkChoice = document.getElementById('networkSelect').value;
      const selectedNetwork = NETWORKS[networkChoice];
      const publicProvider = new ethers.providers.JsonRpcProvider(selectedNetwork.rpc);
      return new ethers.Contract(CONTRACT_ADDRESS, [
        "function poolInfo(uint256) view returns (bool isPaused, uint256 lockPeriod, uint256 apy, uint256 totalStakes, uint256 pauseCheckpoint)",
        "function poolLength() view returns (uint256)"
      ], publicProvider);
    }
    
    // Refresh pool list using the public read-only contract instance
    async function refreshPools() {
      try {
        const publicContract = getPublicContract();
        let poolCount = 0;
        try {
          poolCount = await publicContract.poolLength();
          poolCount = poolCount.toNumber();
        } catch (err) {
          // Fallback: iterate until an error occurs
          while (true) {
            try {
              await publicContract.poolInfo(poolCount);
              poolCount++;
            } catch (error) {
              break;
            }
          }
        }
        
        let poolsHtml = '';
        for (let i = 0; i < poolCount; i++) {
          try {
            const pool = await publicContract.poolInfo(i);
            poolsHtml += `
              <div class="pool-card ${pool.isPaused ? 'paused' : ''}" data-poolid="${i}">
                <div class="pool-info">
                  <h3>Pool #${i}</h3>
                  <p><strong>Status:</strong> ${pool.isPaused ? 'ðŸ”´ Paused' : 'ðŸŸ¢ Active'}</p>
                  <p><strong>APY:</strong> ${formatAPY(pool.apy)}</p>
                  <p><strong>Lock Period:</strong> ${formatDuration(pool.lockPeriod.toNumber())}</p>
                  <p><strong>Total Staked:</strong> ${formatTokens(pool.totalStakes)} TPY</p>
                  ${pool.isPaused ? `<p><strong>Paused At:</strong> ${new Date(pool.pauseCheckpoint.toNumber() * 1000).toLocaleString()}</p>` : ''}
                </div>
                <div class="pool-actions">
                  <input type="text" class="stakeAmount" placeholder="Amount to Stake">
                  <button class="poolStakeButton">Stake</button>
                  <input type="text" class="unstakeAmount" placeholder="Amount to Unstake">
                  <button class="poolUnstakeButton">Unstake</button>
                  <div class="poolActionResult"></div>
                </div>
              </div>
            `;
          } catch (innerError) {
            console.error("Error fetching pool index " + i + ":", innerError);
          }
        }
        document.getElementById('poolList').innerHTML = poolsHtml || '<p>No pools available</p>';
        attachPoolActionListeners();
      } catch (error) {
        console.error('Error fetching pools:', error);
        document.getElementById('poolList').innerHTML = '<p>Error loading pools: ' + error.message + '</p>';
      }
    }
    
    // Attach event listeners for the inline stake/unstake buttons in each pool card
    function attachPoolActionListeners() {
      document.querySelectorAll('.poolStakeButton').forEach(button => {
        button.addEventListener('click', async function() {
          const card = this.closest('.pool-card');
          const poolId = card.getAttribute('data-poolid');
          const amount = card.querySelector('.stakeAmount').value;
          const resultDiv = card.querySelector('.poolActionResult');
          if (!contract) {
            alert('Please connect your wallet first to perform staking.');
            return;
          }
          try {
            // Here, referrerId is set to 0; modify as needed.
            const tx = await contract.stake(poolId, amount, 0);
            resultDiv.innerText = "Transaction sent: " + tx.hash;
            await tx.wait();
            resultDiv.innerText = "Stake successful: " + tx.hash;
          } catch (error) {
            resultDiv.innerText = "Error: " + error.message;
          }
        });
      });
      document.querySelectorAll('.poolUnstakeButton').forEach(button => {
        button.addEventListener('click', async function() {
          const card = this.closest('.pool-card');
          const poolId = card.getAttribute('data-poolid');
          const amount = card.querySelector('.unstakeAmount').value;
          const resultDiv = card.querySelector('.poolActionResult');
          if (!contract) {
            alert('Please connect your wallet first to perform unstaking.');
            return;
          }
          try {
            const tx = await contract.unstake(poolId, amount);
            resultDiv.innerText = "Transaction sent: " + tx.hash;
            await tx.wait();
            resultDiv.innerText = "Unstake successful: " + tx.hash;
          } catch (error) {
            resultDiv.innerText = "Error: " + error.message;
          }
        });
      });
    }
    
    // Connect wallet and instantiate the write contract using the wallet's signer.
    async function connectWallet() {
      if (window.ethereum) {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        const userAddress = await signer.getAddress();
        document.getElementById('walletAddress').innerText = userAddress;
        // Check that wallet is on the selected network.
        const networkChoice = document.getElementById('networkSelect').value;
        const selectedNetwork = NETWORKS[networkChoice];
        const network = await provider.getNetwork();
        if (network.chainId !== selectedNetwork.chainId) {
          alert(`Please switch your wallet network to ${networkChoice}`);
          return;
        }
        contract = new ethers.Contract(CONTRACT_ADDRESS, tpyStakingABI, signer);
      } else {
        alert("Please install a Web3 wallet like MetaMask.");
      }
    }
    
    // Event listeners
    document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
    document.getElementById('refreshPoolsButton').addEventListener('click', refreshPools);
    
    // Automatically refresh pools on page load.
    refreshPools();
  </script>
</body>
</html>
